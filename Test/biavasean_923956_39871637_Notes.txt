//COMPUTATIONAL COMPLEXITY
*I am using a true linked list class and not passing a linked list or a pointer.
-Insert: O(n): Inserting in a singly linked list takes at the maximum O(n) if you input the index.
-InsertEnd: O(1): Inserting at the end of a singly linked list is always o(1) since we know where the tail is.
-edit: O(n):  Since we may have to index all the way through the list, this function is O(n);
-print: O(n): Since we are printing each individual node, the computational complexity is dependent
on the size of the linked-list.
-delete: O(n): The worst case scenario for deleting a node is to delete the last node after starting at the first,
meaning the computational complexity is O(n)
-quit: O(1)



//THINGS LEARNED
	*I don't need to return the head of a list ever, not if I'm using a linked list class.  This gives me a more robust use
	of the list ive made.  
		->If I only made a struct, I would have to pass pointers through. 
	*Using the class and instantiating it as a pointer helps with not having to copy the LinkedList each time it is called,
	I am only passing a pointer to the memory location of the Linked List. Allowing me to edit without copying the object

	Fix.  I can just use the list->print() with no parameter.  this way nothing is being copied.
	Silly me. 


		